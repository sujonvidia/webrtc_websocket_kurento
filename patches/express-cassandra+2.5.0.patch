diff --git a/node_modules/express-cassandra/lib/helpers/driver.js b/node_modules/express-cassandra/lib/helpers/driver.js
index 60c7712..5959e22 100644
--- a/node_modules/express-cassandra/lib/helpers/driver.js
+++ b/node_modules/express-cassandra/lib/helpers/driver.js
@@ -52,13 +52,48 @@ Driver.prototype = {
         return;
       }
       debug('executing query: %s with params: %j', query, params);
-      _this2._properties.cql.execute(query, params, options, function (err1, result) {
-        if (err1 && err1.code === 8704) {
-          _this2.execute_definition_query(query, callback);
-        } else {
-          callback(err1, result);
-        }
-      });
+      var firstWord = query.replace(/ .*/, '').toLowerCase();
+      
+      // if(redis_cache_enabled && redis_cache_ok && firstWord != 'select'){
+        
+      //   client_side_redis.push({
+      //     type: 'CQL',
+      //     query:query,
+      //     params:params,
+      //     options:options,
+      //     _this: _this2,
+      //     callback:callback
+      //   });
+    
+      // }else{
+
+        let mark_cass_driver = Date.now();
+        _this2._properties.cql.execute(query, params, options, function (err1, result) {
+          if (err1 && err1.code === 8704) {
+            _this2.execute_definition_query(query, callback);
+          } else {
+            callback(err1, result);
+          }
+          let table_name = _this2._properties.table_name;
+          if (firstWord == 'update' && model_cache_schema[table_name] && redis_cache_enabled) {
+            let bbb_cassa_up_diff = Date.now() - mark_cass_driver;
+            bbb_cassa_up_total += bbb_cassa_up_diff;
+            console.log(`_caching:cassa:update:sl:${countttt}, this: ${bbb_cassa_up_diff}ms, total: ${bbb_cassa_up_total}ms, table:${table_name}`);
+          }
+          if (firstWord == 'delete' && model_cache_schema[table_name] && redis_cache_enabled) {
+            let bbb_cassa_del_diff = Date.now() - mark_cass_driver;
+            bbb_cassa_del_total += bbb_cassa_del_diff;
+            console.log(`_caching:cassa:delete:sl:${countttt}, this: ${bbb_cassa_del_diff}ms, total: ${bbb_cassa_del_total}ms, table:${table_name}`);
+          }
+          if (firstWord == 'insert' && model_cache_schema[table_name] && redis_cache_enabled) {
+            let bbb_cassa_insert_diff = Date.now() - mark_cass_driver;
+            bbb_cassa_insert_total += bbb_cassa_insert_diff;
+            console.log(`_caching:cassa:insert:sl:${countttt}, this: ${bbb_cassa_insert_diff}ms, total: ${bbb_cassa_insert_total}ms, table:${table_name}`);
+          }
+          
+        });
+
+      // }
     });
   },
 
diff --git a/node_modules/express-cassandra/lib/orm/base_model.js b/node_modules/express-cassandra/lib/orm/base_model.js
index 0ea662c..8f3d2fb 100644
--- a/node_modules/express-cassandra/lib/orm/base_model.js
+++ b/node_modules/express-cassandra/lib/orm/base_model.js
@@ -6,10 +6,10 @@ var util = require('util');
 
 var dseDriver = void 0;
 try {
-  // eslint-disable-next-line import/no-extraneous-dependencies, import/no-unresolved
-  dseDriver = require('dse-driver');
+    // eslint-disable-next-line import/no-extraneous-dependencies, import/no-unresolved
+    dseDriver = require('dse-driver');
 } catch (e) {
-  dseDriver = null;
+    dseDriver = null;
 }
 
 var cql = Promise.promisifyAll(dseDriver || require('cassandra-driver'));
@@ -25,1138 +25,1264 @@ var JanusGraphBuilder = require('../builders/janusgraph');
 var Driver = require('../helpers/driver');
 
 var BaseModel = function f(instanceValues) {
-  instanceValues = instanceValues || {};
-  var fieldValues = {};
-  var fields = this.constructor._properties.schema.fields;
-  var methods = this.constructor._properties.schema.methods || {};
-  var model = this;
-
-  var defaultSetter = function f1(propName, newValue) {
-    if (this[propName] !== newValue) {
-      model._modified[propName] = true;
-    }
-    this[propName] = newValue;
-  };
+    instanceValues = instanceValues || {};
+    var fieldValues = {};
+    var fields = this.constructor._properties.schema.fields;
+    var methods = this.constructor._properties.schema.methods || {};
+    var model = this;
+
+    var defaultSetter = function f1(propName, newValue) {
+        if (this[propName] !== newValue) {
+            model._modified[propName] = true;
+        }
+        this[propName] = newValue;
+    };
 
-  var defaultGetter = function f1(propName) {
-    return this[propName];
-  };
+    var defaultGetter = function f1(propName) {
+        return this[propName];
+    };
 
-  this._modified = {};
-  this._validators = {};
+    this._modified = {};
+    this._validators = {};
 
-  for (var fieldsKeys = Object.keys(fields), i = 0, len = fieldsKeys.length; i < len; i++) {
-    var propertyName = fieldsKeys[i];
-    var field = fields[fieldsKeys[i]];
+    for (var fieldsKeys = Object.keys(fields), i = 0, len = fieldsKeys.length; i < len; i++) {
+        var propertyName = fieldsKeys[i];
+        var field = fields[fieldsKeys[i]];
 
-    try {
-      this._validators[propertyName] = schemer.get_validators(this.constructor._properties.schema, propertyName);
-    } catch (e) {
-      throw buildError('model.validator.invalidschema', e.message);
-    }
+        try {
+            this._validators[propertyName] = schemer.get_validators(this.constructor._properties.schema, propertyName);
+        } catch (e) {
+            throw buildError('model.validator.invalidschema', e.message);
+        }
 
-    var setter = defaultSetter.bind(fieldValues, propertyName);
-    var getter = defaultGetter.bind(fieldValues, propertyName);
+        var setter = defaultSetter.bind(fieldValues, propertyName);
+        var getter = defaultGetter.bind(fieldValues, propertyName);
 
-    if (field.virtual && typeof field.virtual.set === 'function') {
-      setter = field.virtual.set.bind(fieldValues);
-    }
+        if (field.virtual && typeof field.virtual.set === 'function') {
+            setter = field.virtual.set.bind(fieldValues);
+        }
 
-    if (field.virtual && typeof field.virtual.get === 'function') {
-      getter = field.virtual.get.bind(fieldValues);
-    }
+        if (field.virtual && typeof field.virtual.get === 'function') {
+            getter = field.virtual.get.bind(fieldValues);
+        }
 
-    var descriptor = {
-      enumerable: true,
-      set: setter,
-      get: getter
-    };
+        var descriptor = {
+            enumerable: true,
+            set: setter,
+            get: getter
+        };
 
-    Object.defineProperty(this, propertyName, descriptor);
-    if (field.virtual && typeof instanceValues[propertyName] !== 'undefined') {
-      this[propertyName] = instanceValues[propertyName];
+        Object.defineProperty(this, propertyName, descriptor);
+        if (field.virtual && typeof instanceValues[propertyName] !== 'undefined') {
+            this[propertyName] = instanceValues[propertyName];
+        }
     }
-  }
 
-  for (var _fieldsKeys = Object.keys(fields), _i = 0, _len = _fieldsKeys.length; _i < _len; _i++) {
-    var _propertyName = _fieldsKeys[_i];
-    var _field = fields[_fieldsKeys[_i]];
+    for (var _fieldsKeys = Object.keys(fields), _i = 0, _len = _fieldsKeys.length; _i < _len; _i++) {
+        var _propertyName = _fieldsKeys[_i];
+        var _field = fields[_fieldsKeys[_i]];
 
-    if (!_field.virtual && typeof instanceValues[_propertyName] !== 'undefined') {
-      this[_propertyName] = instanceValues[_propertyName];
+        if (!_field.virtual && typeof instanceValues[_propertyName] !== 'undefined') {
+            this[_propertyName] = instanceValues[_propertyName];
+        }
     }
-  }
 
-  for (var methodNames = Object.keys(methods), _i2 = 0, _len2 = methodNames.length; _i2 < _len2; _i2++) {
-    var methodName = methodNames[_i2];
-    var method = methods[methodName];
-    this[methodName] = method;
-  }
+    for (var methodNames = Object.keys(methods), _i2 = 0, _len2 = methodNames.length; _i2 < _len2; _i2++) {
+        var methodName = methodNames[_i2];
+        var method = methods[methodName];
+        this[methodName] = method;
+    }
 };
 
 BaseModel._properties = {
-  name: null,
-  schema: null
+    name: null,
+    schema: null
 };
 
 BaseModel._set_properties = function f(properties) {
-  var schema = properties.schema;
-  var tableName = schema.table_name || properties.name;
+    var schema = properties.schema;
+    var tableName = schema.table_name || properties.name;
 
-  if (!schemer.validate_table_name(tableName)) {
-    throw buildError('model.tablecreation.invalidname', tableName);
-  }
+    if (!schemer.validate_table_name(tableName)) {
+        throw buildError('model.tablecreation.invalidname', tableName);
+    }
 
-  var qualifiedTableName = util.format('"%s"."%s"', properties.keyspace, tableName);
+    var qualifiedTableName = util.format('"%s"."%s"', properties.keyspace, tableName);
 
-  this._properties = properties;
-  this._properties.table_name = tableName;
-  this._properties.qualified_table_name = qualifiedTableName;
-  this._driver = new Driver(this._properties);
+    this._properties = properties;
+    this._properties.table_name = tableName;
+    this._properties.qualified_table_name = qualifiedTableName;
+    this._driver = new Driver(this._properties);
 };
 
 BaseModel._sync_model_definition = function f(callback) {
-  var properties = this._properties;
-  var tableName = properties.table_name;
-  var modelSchema = properties.schema;
-  var migration = properties.migration;
-
-  var tableBuilder = new TableBuilder(this._driver, this._properties);
-
-  // backwards compatible change, dropTableOnSchemaChange will work like migration: 'drop'
-  if (!migration) {
-    if (properties.dropTableOnSchemaChange) migration = 'drop';else migration = 'safe';
-  }
-  // always safe migrate if NODE_ENV==='production'
-  if (process.env.NODE_ENV === 'production') migration = 'safe';
-
-  // check for existence of table on DB and if it matches this model's schema
-  tableBuilder.get_table_schema(function (err, dbSchema) {
-    if (err) {
-      callback(err);
-      return;
-    }
+    var properties = this._properties;
+    var tableName = properties.table_name;
+    var modelSchema = properties.schema;
+    var migration = properties.migration;
 
-    var afterDBCreate = function afterDBCreate(err1) {
-      if (err1) {
-        callback(err1);
-        return;
-      }
+    var tableBuilder = new TableBuilder(this._driver, this._properties);
 
-      var indexingTasks = [];
-
-      // cassandra index create if defined
-      if (_.isArray(modelSchema.indexes)) {
-        tableBuilder.createIndexesAsync = Promise.promisify(tableBuilder.create_indexes);
-        indexingTasks.push(tableBuilder.createIndexesAsync(modelSchema.indexes));
-      }
-      // cassandra custom index create if defined
-      if (_.isArray(modelSchema.custom_indexes)) {
-        tableBuilder.createCustomIndexesAsync = Promise.promisify(tableBuilder.create_custom_indexes);
-        indexingTasks.push(tableBuilder.createCustomIndexesAsync(modelSchema.custom_indexes));
-      }
-      if (modelSchema.custom_index) {
-        tableBuilder.createCustomIndexAsync = Promise.promisify(tableBuilder.create_custom_indexes);
-        indexingTasks.push(tableBuilder.createCustomIndexAsync([modelSchema.custom_index]));
-      }
-      // materialized view create if defined
-      if (modelSchema.materialized_views) {
-        tableBuilder.createViewsAsync = Promise.promisify(tableBuilder.create_mviews);
-        indexingTasks.push(tableBuilder.createViewsAsync(modelSchema.materialized_views));
-      }
+    // backwards compatible change, dropTableOnSchemaChange will work like migration: 'drop'
+    if (!migration) {
+        if (properties.dropTableOnSchemaChange) migration = 'drop';
+        else migration = 'safe';
+    }
+    // always safe migrate if NODE_ENV==='production'
+    if (process.env.NODE_ENV === 'production') migration = 'safe';
 
-      Promise.all(indexingTasks).then(function () {
-        // db schema was updated, so callback with true
-        callback(null, true);
-      }).catch(function (err2) {
-        callback(err2);
-      });
-    };
+    // check for existence of table on DB and if it matches this model's schema
+    tableBuilder.get_table_schema(function(err, dbSchema) {
+        if (err) {
+            callback(err);
+            return;
+        }
 
-    if (!dbSchema) {
-      if (properties.createTable === false) {
-        callback(buildError('model.tablecreation.schemanotfound', tableName));
-        return;
-      }
-      // if not existing, it's created
-      tableBuilder.create_table(modelSchema, afterDBCreate);
-      return;
-    }
+        var afterDBCreate = function afterDBCreate(err1) {
+            if (err1) {
+                callback(err1);
+                return;
+            }
+
+            var indexingTasks = [];
+
+            // cassandra index create if defined
+            if (_.isArray(modelSchema.indexes)) {
+                tableBuilder.createIndexesAsync = Promise.promisify(tableBuilder.create_indexes);
+                indexingTasks.push(tableBuilder.createIndexesAsync(modelSchema.indexes));
+            }
+            // cassandra custom index create if defined
+            if (_.isArray(modelSchema.custom_indexes)) {
+                tableBuilder.createCustomIndexesAsync = Promise.promisify(tableBuilder.create_custom_indexes);
+                indexingTasks.push(tableBuilder.createCustomIndexesAsync(modelSchema.custom_indexes));
+            }
+            if (modelSchema.custom_index) {
+                tableBuilder.createCustomIndexAsync = Promise.promisify(tableBuilder.create_custom_indexes);
+                indexingTasks.push(tableBuilder.createCustomIndexAsync([modelSchema.custom_index]));
+            }
+            // materialized view create if defined
+            if (modelSchema.materialized_views) {
+                tableBuilder.createViewsAsync = Promise.promisify(tableBuilder.create_mviews);
+                indexingTasks.push(tableBuilder.createViewsAsync(modelSchema.materialized_views));
+            }
+
+            Promise.all(indexingTasks).then(function() {
+                // db schema was updated, so callback with true
+                callback(null, true);
+            }).catch(function(err2) {
+                callback(err2);
+            });
+        };
+
+        if (!dbSchema) {
+            if (properties.createTable === false) {
+                callback(buildError('model.tablecreation.schemanotfound', tableName));
+                return;
+            }
+            // if not existing, it's created
+            tableBuilder.create_table(modelSchema, afterDBCreate);
+            return;
+        }
 
-    var normalizedModelSchema = void 0;
-    var normalizedDBSchema = void 0;
+        var normalizedModelSchema = void 0;
+        var normalizedDBSchema = void 0;
 
-    try {
-      normalizedModelSchema = normalizer.normalize_model_schema(modelSchema);
-      normalizedDBSchema = normalizer.normalize_model_schema(dbSchema);
-    } catch (e) {
-      throw buildError('model.validator.invalidschema', e.message);
-    }
+        try {
+            normalizedModelSchema = normalizer.normalize_model_schema(modelSchema);
+            normalizedDBSchema = normalizer.normalize_model_schema(dbSchema);
+        } catch (e) {
+            throw buildError('model.validator.invalidschema', e.message);
+        }
 
-    if (_.isEqual(normalizedModelSchema, normalizedDBSchema)) {
-      // no change in db was made, so callback with false
-      callback(null, false);
-      return;
-    }
+        if (_.isEqual(normalizedModelSchema, normalizedDBSchema)) {
+            // no change in db was made, so callback with false
+            callback(null, false);
+            return;
+        }
 
-    if (migration === 'alter') {
-      // check if table can be altered to match schema
-      if (_.isEqual(normalizedModelSchema.key, normalizedDBSchema.key) && _.isEqual(normalizedModelSchema.clustering_order, normalizedDBSchema.clustering_order)) {
-        tableBuilder.init_alter_operations(modelSchema, dbSchema, normalizedModelSchema, normalizedDBSchema, function (err1) {
-          if (err1 && err1.message === 'alter_impossible') {
+        if (migration === 'alter') {
+            // check if table can be altered to match schema
+            if (_.isEqual(normalizedModelSchema.key, normalizedDBSchema.key) && _.isEqual(normalizedModelSchema.clustering_order, normalizedDBSchema.clustering_order)) {
+                tableBuilder.init_alter_operations(modelSchema, dbSchema, normalizedModelSchema, normalizedDBSchema, function(err1) {
+                    if (err1 && err1.message === 'alter_impossible') {
+                        tableBuilder.drop_recreate_table(modelSchema, normalizedDBSchema.materialized_views, afterDBCreate);
+                        return;
+                    }
+                    callback(err1);
+                });
+            } else {
+                tableBuilder.drop_recreate_table(modelSchema, normalizedDBSchema.materialized_views, afterDBCreate);
+            }
+        } else if (migration === 'drop') {
             tableBuilder.drop_recreate_table(modelSchema, normalizedDBSchema.materialized_views, afterDBCreate);
-            return;
-          }
-          callback(err1);
-        });
-      } else {
-        tableBuilder.drop_recreate_table(modelSchema, normalizedDBSchema.materialized_views, afterDBCreate);
-      }
-    } else if (migration === 'drop') {
-      tableBuilder.drop_recreate_table(modelSchema, normalizedDBSchema.materialized_views, afterDBCreate);
-    } else {
-      callback(buildError('model.tablecreation.schemamismatch', tableName, 'migration suspended, please apply the change manually'));
-    }
-  });
+        } else {
+            callback(buildError('model.tablecreation.schemamismatch', tableName, 'migration suspended, please apply the change manually'));
+        }
+    });
 };
 
 BaseModel._sync_es_index = function f(callback) {
-  var properties = this._properties;
-
-  if (properties.esclient && properties.schema.es_index_mapping) {
-    var keyspaceName = properties.keyspace;
-    var mappingName = properties.table_name;
-    var indexName = `${keyspaceName}_${mappingName}`;
-
-    var elassandraBuilder = new ElassandraBuilder(properties.esclient);
-    elassandraBuilder.assert_index(keyspaceName, indexName, function (err) {
-      if (err) {
-        callback(err);
+    var properties = this._properties;
+
+    if (properties.esclient && properties.schema.es_index_mapping) {
+        var keyspaceName = properties.keyspace;
+        var mappingName = properties.table_name;
+        var indexName = `${keyspaceName}_${mappingName}`;
+
+        var elassandraBuilder = new ElassandraBuilder(properties.esclient);
+        elassandraBuilder.assert_index(keyspaceName, indexName, function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            elassandraBuilder.put_mapping(indexName, mappingName, properties.schema.es_index_mapping, callback);
+        });
         return;
-      }
-      elassandraBuilder.put_mapping(indexName, mappingName, properties.schema.es_index_mapping, callback);
-    });
-    return;
-  }
-  callback();
+    }
+    callback();
 };
 
 BaseModel._sync_graph = function f(callback) {
-  var properties = this._properties;
-
-  if (properties.gremlin_client && properties.schema.graph_mapping) {
-    var graphName = `${properties.keyspace}_graph`;
-    var mappingName = properties.table_name;
-
-    var graphBuilder = new JanusGraphBuilder(properties.gremlin_client);
-    graphBuilder.assert_graph(graphName, function (err) {
-      if (err) {
-        callback(err);
+    var properties = this._properties;
+
+    if (properties.gremlin_client && properties.schema.graph_mapping) {
+        var graphName = `${properties.keyspace}_graph`;
+        var mappingName = properties.table_name;
+
+        var graphBuilder = new JanusGraphBuilder(properties.gremlin_client);
+        graphBuilder.assert_graph(graphName, function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            graphBuilder.put_mapping(graphName, mappingName, properties.schema.graph_mapping, callback);
+        });
         return;
-      }
-      graphBuilder.put_mapping(graphName, mappingName, properties.schema.graph_mapping, callback);
-    });
-    return;
-  }
-  callback();
+    }
+    callback();
 };
 
 BaseModel._execute_table_query = function f(query, params, options, callback) {
-  if (arguments.length === 3) {
-    callback = options;
-    options = {};
-  }
-
-  var defaults = {
-    prepare: true
-  };
-
-  options = _.defaultsDeep(options, defaults);
-
-  var doExecuteQuery = function f1(doquery, docallback) {
-    this.execute_query(doquery, params, options, docallback);
-  }.bind(this, query);
-
-  if (this.is_table_ready()) {
-    doExecuteQuery(callback);
-  } else {
-    this.init(function (err) {
-      if (err) {
-        callback(err);
-        return;
-      }
-      doExecuteQuery(callback);
-    });
-  }
+    if (arguments.length === 3) {
+        callback = options;
+        options = {};
+    }
+
+    var defaults = {
+        prepare: true
+    };
+
+    options = _.defaultsDeep(options, defaults);
+
+    var doExecuteQuery = function f1(doquery, docallback) {
+        this.execute_query(doquery, params, options, docallback);
+    }.bind(this, query);
+
+    if (this.is_table_ready()) {
+        doExecuteQuery(callback);
+    } else {
+        this.init(function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            doExecuteQuery(callback);
+        });
+    }
 };
 
 BaseModel.get_find_query = function f(queryObject, options) {
-  var orderbyClause = parser.get_orderby_clause(queryObject);
-  var limitClause = parser.get_limit_clause(queryObject);
-  var whereClause = parser.get_where_clause(this._properties.schema, queryObject);
-  var selectClause = parser.get_select_clause(options);
-  var groupbyClause = parser.get_groupby_clause(options);
+    var orderbyClause = parser.get_orderby_clause(queryObject);
+    var limitClause = parser.get_limit_clause(queryObject);
+    var whereClause = parser.get_where_clause(this._properties.schema, queryObject);
+    var selectClause = parser.get_select_clause(options);
+    var groupbyClause = parser.get_groupby_clause(options);
 
-  var query = util.format('SELECT %s%s FROM "%s"', options.distinct ? 'DISTINCT ' : '', selectClause, options.materialized_view ? options.materialized_view : this._properties.table_name);
+    var query = util.format('SELECT %s%s FROM "%s"', options.distinct ? 'DISTINCT ' : '', selectClause, options.materialized_view ? options.materialized_view : this._properties.table_name);
 
-  if (whereClause.query) query += util.format(' %s', whereClause.query);
-  if (orderbyClause) query += util.format(' %s', orderbyClause);
-  if (groupbyClause) query += util.format(' %s', groupbyClause);
-  if (limitClause) query += util.format(' %s', limitClause);
-  if (options.allow_filtering) query += ' ALLOW FILTERING';
+    if (whereClause.query) query += util.format(' %s', whereClause.query);
+    if (orderbyClause) query += util.format(' %s', orderbyClause);
+    if (groupbyClause) query += util.format(' %s', groupbyClause);
+    if (limitClause) query += util.format(' %s', limitClause);
+    if (options.allow_filtering) query += ' ALLOW FILTERING';
 
-  query += ';';
+    query += ';';
 
-  return { query, params: whereClause.params };
+    return { query, params: whereClause.params };
 };
 
 BaseModel.get_table_name = function f() {
-  return this._properties.table_name;
+    return this._properties.table_name;
 };
 
 BaseModel.get_keyspace_name = function f() {
-  return this._properties.keyspace;
+    return this._properties.keyspace;
 };
 
 BaseModel.is_table_ready = function f() {
-  return this._ready === true;
+    return this._ready === true;
 };
 
 BaseModel.init = function f(options, callback) {
-  if (!callback) {
-    callback = options;
-    options = undefined;
-  }
+    if (!callback) {
+        callback = options;
+        options = undefined;
+    }
 
-  this._ready = true;
-  callback();
+    this._ready = true;
+    callback();
 };
 
 BaseModel.syncDB = function f(callback) {
-  var _this = this;
+    var _this = this;
 
-  this._sync_model_definition(function (err, result) {
-    if (err) {
-      callback(err);
-      return;
-    }
-
-    _this._sync_es_index(function (err1) {
-      if (err1) {
-        callback(err1);
-        return;
-      }
-
-      _this._sync_graph(function (err2) {
-        if (err2) {
-          callback(err2);
-          return;
+    this._sync_model_definition(function(err, result) {
+        if (err) {
+            callback(err);
+            return;
         }
 
-        _this._ready = true;
-        callback(null, result);
-      });
+        _this._sync_es_index(function(err1) {
+            if (err1) {
+                callback(err1);
+                return;
+            }
+
+            _this._sync_graph(function(err2) {
+                if (err2) {
+                    callback(err2);
+                    return;
+                }
+
+                _this._ready = true;
+                callback(null, result);
+            });
+        });
     });
-  });
 };
 
 BaseModel.get_cql_client = function f(callback) {
-  var _this2 = this;
+    var _this2 = this;
 
-  this._driver.ensure_init(function (err) {
-    if (err) {
-      callback(err);
-      return;
-    }
-    callback(null, _this2._properties.cql);
-  });
+    this._driver.ensure_init(function(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, _this2._properties.cql);
+    });
 };
 
 BaseModel.get_es_client = function f() {
-  if (!this._properties.esclient) {
-    throw new Error('To use elassandra features, set `manageESIndex` to true in ormOptions');
-  }
-  return this._properties.esclient;
+    if (!this._properties.esclient) {
+        throw new Error('To use elassandra features, set `manageESIndex` to true in ormOptions');
+    }
+    return this._properties.esclient;
 };
 
 BaseModel.get_gremlin_client = function f() {
-  if (!this._properties.gremlin_client) {
-    throw new Error('To use janus graph features, set `manageGraphs` to true in ormOptions');
-  }
-  return this._properties.gremlin_client;
+    if (!this._properties.gremlin_client) {
+        throw new Error('To use janus graph features, set `manageGraphs` to true in ormOptions');
+    }
+    return this._properties.gremlin_client;
 };
 
 BaseModel.execute_query = function f() {
-  var _driver;
+    var _driver;
 
-  (_driver = this._driver).execute_query.apply(_driver, arguments);
+    (_driver = this._driver).execute_query.apply(_driver, arguments);
 };
 
 BaseModel.execute_batch = function f() {
-  var _driver2;
+    var _driver2;
 
-  (_driver2 = this._driver).execute_batch.apply(_driver2, arguments);
+    (_driver2 = this._driver).execute_batch.apply(_driver2, arguments);
 };
 
 BaseModel.execute_eachRow = function f() {
-  var _driver3;
+    var _driver3;
 
-  (_driver3 = this._driver).execute_eachRow.apply(_driver3, arguments);
+    (_driver3 = this._driver).execute_eachRow.apply(_driver3, arguments);
 };
 
 BaseModel._execute_table_eachRow = function f(query, params, options, onReadable, callback) {
-  var _this3 = this;
-
-  if (this.is_table_ready()) {
-    this.execute_eachRow(query, params, options, onReadable, callback);
-  } else {
-    this.init(function (err) {
-      if (err) {
-        callback(err);
-        return;
-      }
-      _this3.execute_eachRow(query, params, options, onReadable, callback);
-    });
-  }
+    var _this3 = this;
+
+    if (this.is_table_ready()) {
+        this.execute_eachRow(query, params, options, onReadable, callback);
+    } else {
+        this.init(function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            _this3.execute_eachRow(query, params, options, onReadable, callback);
+        });
+    }
 };
 
 BaseModel.eachRow = function f(queryObject, options, onReadable, callback) {
-  var _this4 = this;
-
-  if (arguments.length === 3) {
-    var cb = onReadable;
-    onReadable = options;
-    callback = cb;
-    options = {};
-  }
-  if (typeof onReadable !== 'function') {
-    throw buildError('model.find.eachrowerror', 'no valid onReadable function was provided');
-  }
-  if (typeof callback !== 'function') {
-    throw buildError('model.find.cberror');
-  }
-
-  var defaults = {
-    raw: false,
-    prepare: true
-  };
-
-  options = _.defaultsDeep(options, defaults);
-
-  options.return_query = true;
-  var selectQuery = this.find(queryObject, options);
-
-  var queryOptions = normalizer.normalize_query_option(options);
-
-  this._execute_table_eachRow(selectQuery.query, selectQuery.params, queryOptions, function (n, row) {
-    if (!options.raw) {
-      var ModelConstructor = _this4._properties.get_constructor();
-      row = new ModelConstructor(row);
-      row._modified = {};
+    var _this4 = this;
+
+    if (arguments.length === 3) {
+        var cb = onReadable;
+        onReadable = options;
+        callback = cb;
+        options = {};
     }
-    onReadable(n, row);
-  }, function (err, result) {
-    if (err) {
-      callback(buildError('model.find.dberror', err));
-      return;
+    if (typeof onReadable !== 'function') {
+        throw buildError('model.find.eachrowerror', 'no valid onReadable function was provided');
     }
-    callback(err, result);
-  });
+    if (typeof callback !== 'function') {
+        throw buildError('model.find.cberror');
+    }
+
+    var defaults = {
+        raw: false,
+        prepare: true
+    };
+
+    options = _.defaultsDeep(options, defaults);
+
+    options.return_query = true;
+    var selectQuery = this.find(queryObject, options);
+
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    this._execute_table_eachRow(selectQuery.query, selectQuery.params, queryOptions, function(n, row) {
+        if (!options.raw) {
+            var ModelConstructor = _this4._properties.get_constructor();
+            row = new ModelConstructor(row);
+            row._modified = {};
+        }
+        onReadable(n, row);
+    }, function(err, result) {
+        if (err) {
+            callback(buildError('model.find.dberror', err));
+            return;
+        }
+        callback(err, result);
+    });
 };
 
 BaseModel.execute_stream = function f() {
-  var _driver4;
+    var _driver4;
 
-  (_driver4 = this._driver).execute_stream.apply(_driver4, arguments);
+    (_driver4 = this._driver).execute_stream.apply(_driver4, arguments);
 };
 
 BaseModel._execute_table_stream = function f(query, params, options, onReadable, callback) {
-  var _this5 = this;
-
-  if (this.is_table_ready()) {
-    this.execute_stream(query, params, options, onReadable, callback);
-  } else {
-    this.init(function (err) {
-      if (err) {
-        callback(err);
-        return;
-      }
-      _this5.execute_stream(query, params, options, onReadable, callback);
-    });
-  }
+    var _this5 = this;
+
+    if (this.is_table_ready()) {
+        this.execute_stream(query, params, options, onReadable, callback);
+    } else {
+        this.init(function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            _this5.execute_stream(query, params, options, onReadable, callback);
+        });
+    }
 };
 
 BaseModel.stream = function f(queryObject, options, onReadable, callback) {
-  if (arguments.length === 3) {
-    var cb = onReadable;
-    onReadable = options;
-    callback = cb;
-    options = {};
-  }
-
-  if (typeof onReadable !== 'function') {
-    throw buildError('model.find.streamerror', 'no valid onReadable function was provided');
-  }
-  if (typeof callback !== 'function') {
-    throw buildError('model.find.cberror');
-  }
-
-  var defaults = {
-    raw: false,
-    prepare: true
-  };
-
-  options = _.defaultsDeep(options, defaults);
-
-  options.return_query = true;
-  var selectQuery = this.find(queryObject, options);
-
-  var queryOptions = normalizer.normalize_query_option(options);
-
-  var self = this;
-
-  this._execute_table_stream(selectQuery.query, selectQuery.params, queryOptions, function f1() {
-    var reader = this;
-    reader.readRow = function () {
-      var row = reader.read();
-      if (!row) return row;
-      if (!options.raw) {
-        var ModelConstructor = self._properties.get_constructor();
-        var o = new ModelConstructor(row);
-        o._modified = {};
-        return o;
-      }
-      return row;
-    };
-    onReadable(reader);
-  }, function (err) {
-    if (err) {
-      callback(buildError('model.find.dberror', err));
-      return;
+    if (arguments.length === 3) {
+        var cb = onReadable;
+        onReadable = options;
+        callback = cb;
+        options = {};
     }
-    callback();
-  });
+
+    if (typeof onReadable !== 'function') {
+        throw buildError('model.find.streamerror', 'no valid onReadable function was provided');
+    }
+    if (typeof callback !== 'function') {
+        throw buildError('model.find.cberror');
+    }
+
+    var defaults = {
+        raw: false,
+        prepare: true
+    };
+
+    options = _.defaultsDeep(options, defaults);
+
+    options.return_query = true;
+    var selectQuery = this.find(queryObject, options);
+
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    var self = this;
+
+    this._execute_table_stream(selectQuery.query, selectQuery.params, queryOptions, function f1() {
+        var reader = this;
+        reader.readRow = function() {
+            var row = reader.read();
+            if (!row) return row;
+            if (!options.raw) {
+                var ModelConstructor = self._properties.get_constructor();
+                var o = new ModelConstructor(row);
+                o._modified = {};
+                return o;
+            }
+            return row;
+        };
+        onReadable(reader);
+    }, function(err) {
+        if (err) {
+            callback(buildError('model.find.dberror', err));
+            return;
+        }
+        callback();
+    });
 };
 
 BaseModel._execute_gremlin_query = function f(script, bindings, callback) {
-  var gremlinClient = this.get_gremlin_client();
-  gremlinClient.execute(script, bindings, function (err, results) {
-    if (err) {
-      callback(err);
-      return;
-    }
-    callback(null, results);
-  });
+    var gremlinClient = this.get_gremlin_client();
+    gremlinClient.execute(script, bindings, function(err, results) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, results);
+    });
 };
 
 BaseModel._execute_gremlin_script = function f(script, bindings, callback) {
-  this._execute_gremlin_query(script, bindings, function (err, results) {
-    if (err) {
-      callback(err);
-      return;
-    }
-    callback(null, results[0]);
-  });
+    this._execute_gremlin_query(script, bindings, function(err, results) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, results[0]);
+    });
 };
 
 BaseModel.createVertex = function f(vertexProperties, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var __vertexLabel = properties.table_name;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var __vertexLabel = properties.table_name;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     vertex = graph.addVertex(__vertexLabel);
   `;
-  Object.keys(vertexProperties).forEach(function (property) {
-    script += `vertex.property('${property}', ${property});`;
-  });
-  script += 'vertex';
-  var bindings = _.defaults(vertexProperties, {
-    __graphName,
-    __vertexLabel
-  });
-  this._execute_gremlin_script(script, bindings, callback);
+    Object.keys(vertexProperties).forEach(function(property) {
+        script += `vertex.property('${property}', ${property});`;
+    });
+    script += 'vertex';
+    var bindings = _.defaults(vertexProperties, {
+        __graphName,
+        __vertexLabel
+    });
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.getVertex = function f(__vertexId, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     vertex = g.V(__vertexId);
   `;
-  var bindings = {
-    __graphName,
-    __vertexId
-  };
-  this._execute_gremlin_script(script, bindings, callback);
+    var bindings = {
+        __graphName,
+        __vertexId
+    };
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.updateVertex = function f(__vertexId, vertexProperties, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     vertex = g.V(__vertexId);
   `;
-  Object.keys(vertexProperties).forEach(function (property) {
-    script += `vertex.property('${property}', ${property});`;
-  });
-  script += 'vertex';
-  var bindings = _.defaults(vertexProperties, {
-    __graphName,
-    __vertexId
-  });
-  this._execute_gremlin_script(script, bindings, callback);
+    Object.keys(vertexProperties).forEach(function(property) {
+        script += `vertex.property('${property}', ${property});`;
+    });
+    script += 'vertex';
+    var bindings = _.defaults(vertexProperties, {
+        __graphName,
+        __vertexId
+    });
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.deleteVertex = function f(__vertexId, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     vertex = g.V(__vertexId);
     vertex.drop();
   `;
-  var bindings = {
-    __graphName,
-    __vertexId
-  };
-  this._execute_gremlin_script(script, bindings, callback);
+    var bindings = {
+        __graphName,
+        __vertexId
+    };
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.createEdge = function f(__edgeLabel, __fromVertexId, __toVertexId, edgeProperties, callback) {
-  if (arguments.length === 4 && typeof edgeProperties === 'function') {
-    callback = edgeProperties;
-    edgeProperties = {};
-  }
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    if (arguments.length === 4 && typeof edgeProperties === 'function') {
+        callback = edgeProperties;
+        edgeProperties = {};
+    }
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     fromVertex = g.V(__fromVertexId).next();
     toVertex = g.V(__toVertexId).next();
     edge = fromVertex.addEdge(__edgeLabel, toVertex);
   `;
-  Object.keys(edgeProperties).forEach(function (property) {
-    script += `edge.property('${property}', ${property});`;
-  });
-  script += 'edge';
-  var bindings = _.defaults(edgeProperties, {
-    __graphName,
-    __fromVertexId,
-    __toVertexId,
-    __edgeLabel
-  });
-  this._execute_gremlin_script(script, bindings, callback);
+    Object.keys(edgeProperties).forEach(function(property) {
+        script += `edge.property('${property}', ${property});`;
+    });
+    script += 'edge';
+    var bindings = _.defaults(edgeProperties, {
+        __graphName,
+        __fromVertexId,
+        __toVertexId,
+        __edgeLabel
+    });
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.getEdge = function f(__edgeId, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     edge = g.E(__edgeId);
   `;
-  var bindings = {
-    __graphName,
-    __edgeId
-  };
-  this._execute_gremlin_script(script, bindings, callback);
+    var bindings = {
+        __graphName,
+        __edgeId
+    };
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.updateEdge = function f(__edgeId, edgeProperties, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     edge = g.E(__edgeId);
   `;
-  Object.keys(edgeProperties).forEach(function (property) {
-    script += `edge.property('${property}', ${property});`;
-  });
-  script += 'edge';
-  var bindings = _.defaults(edgeProperties, {
-    __graphName,
-    __edgeId
-  });
-  this._execute_gremlin_script(script, bindings, callback);
+    Object.keys(edgeProperties).forEach(function(property) {
+        script += `edge.property('${property}', ${property});`;
+    });
+    script += 'edge';
+    var bindings = _.defaults(edgeProperties, {
+        __graphName,
+        __edgeId
+    });
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.deleteEdge = function f(__edgeId, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     edge = g.E(__edgeId);
     edge.drop();
   `;
-  var bindings = {
-    __graphName,
-    __edgeId
-  };
-  this._execute_gremlin_script(script, bindings, callback);
+    var bindings = {
+        __graphName,
+        __edgeId
+    };
+    this._execute_gremlin_script(script, bindings, callback);
 };
 
 BaseModel.graphQuery = function f(query, params, callback) {
-  var properties = this._properties;
-  var __graphName = `${properties.keyspace}_graph`;
-  var __vertexLabel = properties.table_name;
-  var script = `
+    var properties = this._properties;
+    var __graphName = `${properties.keyspace}_graph`;
+    var __vertexLabel = properties.table_name;
+    var script = `
     graph = ConfiguredGraphFactory.open(__graphName);
     g = graph.traversal();
     vertices = g.V().hasLabel(__vertexLabel);
   `;
-  script += query;
-  var bindings = _.defaults(params, {
-    __graphName,
-    __vertexLabel
-  });
-  this._execute_gremlin_query(script, bindings, callback);
+    script += query;
+    var bindings = _.defaults(params, {
+        __graphName,
+        __vertexLabel
+    });
+    this._execute_gremlin_query(script, bindings, callback);
 };
 
 BaseModel.search = function f(queryObject, callback) {
-  var esClient = this.get_es_client();
-  var indexName = `${this._properties.keyspace}_${this._properties.table_name}`;
-
-  var query = _.defaults(queryObject, {
-    index: indexName,
-    type: this._properties.table_name
-  });
-  esClient.search(query, function (err, response) {
-    if (err) {
-      callback(err);
-      return;
-    }
-    callback(null, response);
-  });
+    var esClient = this.get_es_client();
+    var indexName = `${this._properties.keyspace}_${this._properties.table_name}`;
+
+    var query = _.defaults(queryObject, {
+        index: indexName,
+        type: this._properties.table_name
+    });
+    esClient.search(query, function(err, response) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, response);
+    });
 };
 
+// BaseModel.find = function f(queryObject, options, callback) {
+//   var _this6 = this;
+
+//   if (arguments.length === 2 && typeof options === 'function') {
+//     callback = options;
+//     options = {};
+//   }
+//   if (typeof callback !== 'function' && !options.return_query) {
+//     throw buildError('model.find.cberror');
+//   }
+
+//   var defaults = {
+//     raw: false,
+//     prepare: true
+//   };
+
+//   options = _.defaultsDeep(options, defaults);
+
+//   // set raw true if select is used,
+//   // because casting to model instances may lead to problems
+//   if (options.select) options.raw = true;
+
+//   var queryParams = [];
+
+//   var query = void 0;
+//   try {
+//     var findQuery = this.get_find_query(queryObject, options);
+//     query = findQuery.query;
+//     queryParams = queryParams.concat(findQuery.params);
+//   } catch (e) {
+//     parser.callback_or_throw(e, callback);
+//     return {};
+//   }
+
+//   if (options.return_query) {
+//     return { query, params: queryParams };
+//   }
+
+//   var queryOptions = normalizer.normalize_query_option(options);
+
+//   this._execute_table_query(query, queryParams, queryOptions, function (err, results) {
+//     if (err) {
+//       callback(buildError('model.find.dberror', err));
+//       return;
+//     }
+//     if (!options.raw) {
+//       var ModelConstructor = _this6._properties.get_constructor();
+//       results = results.rows.map(function (res) {
+//         delete res.columns;
+//         var o = new ModelConstructor(res);
+//         o._modified = {};
+//         return o;
+//       });
+//       callback(null, results);
+//     } else {
+//       results = results.rows.map(function (res) {
+//         delete res.columns;
+//         return res;
+//       });
+//       callback(null, results);
+//     }
+//   });
+
+//   return {};
+// };
+
 BaseModel.find = function f(queryObject, options, callback) {
-  var _this6 = this;
-
-  if (arguments.length === 2 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
-  if (typeof callback !== 'function' && !options.return_query) {
-    throw buildError('model.find.cberror');
-  }
-
-  var defaults = {
-    raw: false,
-    prepare: true
-  };
-
-  options = _.defaultsDeep(options, defaults);
-
-  // set raw true if select is used,
-  // because casting to model instances may lead to problems
-  if (options.select) options.raw = true;
-
-  var queryParams = [];
-
-  var query = void 0;
-  try {
-    var findQuery = this.get_find_query(queryObject, options);
-    query = findQuery.query;
-    queryParams = queryParams.concat(findQuery.params);
-  } catch (e) {
-    parser.callback_or_throw(e, callback);
-    return {};
-  }
+    // _queryObject = queryObject;
+    var _this6 = this;
 
-  if (options.return_query) {
-    return { query, params: queryParams };
-  }
+    if (arguments.length === 2 && typeof options === 'function') {
+        callback = options;
+        options = {};
+    }
+    if (typeof callback !== 'function' && !options.return_query) {
+        throw buildError('model.find.cberror');
+    }
 
-  var queryOptions = normalizer.normalize_query_option(options);
+    var schema = this._properties.schema;
 
-  this._execute_table_query(query, queryParams, queryOptions, function (err, results) {
-    if (err) {
-      callback(buildError('model.find.dberror', err));
-      return;
+    var defaults = {
+        raw: false,
+        prepare: true
+    };
+
+    options = _.defaultsDeep(options, defaults);
+
+    // if (typeof schema.before_find === 'function' && schema.before_find(queryObject, options,callback) === false) {
+    //   parser.callback_or_throw(buildError('model.find.before.error'), callback);
+    //   return {};
+    // }
+
+    // set raw true if select is used,
+    // because casting to model instances may lead to problems
+    if (options.select) options.raw = true;
+
+    var queryParams = [];
+
+    var query = void 0;
+    try {
+        var findQuery = this.get_find_query(queryObject, options);
+        query = findQuery.query;
+        queryParams = queryParams.concat(findQuery.params);
+    } catch (e) {
+        parser.callback_or_throw(e, callback);
+        return {};
     }
-    if (!options.raw) {
-      var ModelConstructor = _this6._properties.get_constructor();
-      results = results.rows.map(function (res) {
-        delete res.columns;
-        var o = new ModelConstructor(res);
-        o._modified = {};
-        return o;
-      });
-      callback(null, results);
+
+    if (options.return_query) {
+        return { query, params: queryParams };
+    }
+
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    if (redis_cache_enabled && redis_cache_ok && model_cache_schema[this._properties.table_name]) {
+
+        client_side_redis.push({
+            type: 'select',
+            query: query,
+            queryParams: queryParams,
+            queryOptions: queryOptions,
+            queryObject: queryObject,
+            options: options,
+            _this: this,
+            _this6: _this6,
+            buildError: buildError,
+            callback: callback
+        });
+
     } else {
-      results = results.rows.map(function (res) {
-        delete res.columns;
-        return res;
-      });
-      callback(null, results);
+
+        this._execute_table_query(query, queryParams, queryOptions, function(err, results) {
+            if (err) {
+                callback(buildError('model.find.dberror', err));
+                return;
+            }
+            if (!options.raw) {
+                var ModelConstructor = _this6._properties.get_constructor();
+                results = results.rows.map(function(res) {
+                    delete res.columns;
+                    var o = new ModelConstructor(res);
+                    o._modified = {};
+                    return o;
+                });
+                callback(null, results);
+            } else {
+                results = results.rows.map(function(res) {
+                    validate_row_data(res, schema);
+                    delete res.columns;
+                    return res;
+                });
+                callback(null, results);
+            }
+        });
+
     }
-  });
 
-  return {};
+
+    return {};
 };
 
+function validate_row_data(res, schema) {
+    for (let r in res) {
+      if(res[r] == null){
+        var ff = getModelFieldType(schema, r);
+        if(ff == 'set'){
+          res[r] = [];
+
+        }
+
+      }
+        
+    }
+
+
+}
+
+function getModelFieldType(model_object, rowkey) {
+    if (model_object.fields[rowkey][
+            ['type']
+        ]) { var field__type = model_object.fields[rowkey]['type']; } else var field__type = model_object.fields[rowkey];
+    return field__type;
+}
+
 BaseModel.findOne = function f(queryObject, options, callback) {
-  if (arguments.length === 2 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
-  if (typeof callback !== 'function' && !options.return_query) {
-    throw buildError('model.find.cberror');
-  }
-
-  queryObject.$limit = 1;
-
-  return this.find(queryObject, options, function (err, results) {
-    if (err) {
-      callback(err);
-      return;
+    if (arguments.length === 2 && typeof options === 'function') {
+        callback = options;
+        options = {};
     }
-    if (results.length > 0) {
-      callback(null, results[0]);
-      return;
+    if (typeof callback !== 'function' && !options.return_query) {
+        throw buildError('model.find.cberror');
     }
-    callback();
-  });
+
+    queryObject.$limit = 1;
+
+    return this.find(queryObject, options, function(err, results) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (results.length > 0) {
+            callback(null, results[0]);
+            return;
+        }
+        callback();
+    });
 };
 
 BaseModel.update = function f(queryObject, updateValues, options, callback) {
-  if (arguments.length === 3 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
+    // console.log('caching:update:cassa:sl:',countttt,'tbl:', this._properties.table_name,'qryObj:',JSON.stringify(queryObject),'val:',JSON.stringify(updateValues));
+    // _queryObject = queryObject;
+    // _updateValues = updateValues;
+    if (arguments.length === 3 && typeof options === 'function') {
+        callback = options;
+        options = {};
+    }
 
-  var schema = this._properties.schema;
+    var schema = this._properties.schema;
 
-  var defaults = {
-    prepare: true
-  };
+    var defaults = {
+        prepare: true
+    };
 
-  options = _.defaultsDeep(options, defaults);
+    options = _.defaultsDeep(options, defaults);
 
-  if (typeof schema.before_update === 'function' && schema.before_update(queryObject, updateValues, options) === false) {
-    parser.callback_or_throw(buildError('model.update.before.error'), callback);
-    return {};
-  }
-
-  var _parser$get_update_va = parser.get_update_value_expression(this, schema, updateValues, callback),
-      updateClauses = _parser$get_update_va.updateClauses,
-      queryParams = _parser$get_update_va.queryParams,
-      errorHappened = _parser$get_update_va.errorHappened;
-
-  if (errorHappened) return {};
-
-  var query = 'UPDATE "%s"';
-  var finalParams = queryParams;
-  if (_.isNumber(options.ttl)) {
-    query += ' USING TTL ?';
-    finalParams = [options.ttl].concat(finalParams);
-  }
-  query += ' SET %s %s';
-
-  var where = '';
-  try {
-    var whereClause = parser.get_where_clause(schema, queryObject);
-    where = whereClause.query;
-    finalParams = finalParams.concat(whereClause.params);
-  } catch (e) {
-    parser.callback_or_throw(e, callback);
-    return {};
-  }
+    if (typeof schema.before_update === 'function' && schema.before_update(queryObject, updateValues, options) === false) {
+        parser.callback_or_throw(buildError('model.update.before.error'), callback);
+        return {};
+    }
+
+    var _parser$get_update_va = parser.get_update_value_expression(this, schema, updateValues, callback),
+        updateClauses = _parser$get_update_va.updateClauses,
+        queryParams = _parser$get_update_va.queryParams,
+        errorHappened = _parser$get_update_va.errorHappened;
 
-  query = util.format(query, this._properties.table_name, updateClauses.join(', '), where);
+    if (errorHappened) return {};
 
-  if (options.conditions) {
-    var ifClause = parser.get_if_clause(schema, options.conditions);
-    if (ifClause.query) {
-      query += util.format(' %s', ifClause.query);
-      finalParams = finalParams.concat(ifClause.params);
+    var query = 'UPDATE "%s"';
+    var finalParams = queryParams;
+    if (_.isNumber(options.ttl)) {
+        query += ' USING TTL ?';
+        finalParams = [options.ttl].concat(finalParams);
     }
-  } else if (options.if_exists) {
-    query += ' IF EXISTS';
-  }
-
-  query += ';';
-
-  if (options.return_query) {
-    var returnObj = {
-      query,
-      params: finalParams,
-      after_hook: function after_hook() {
-        if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
-          return buildError('model.update.after.error');
-        }
-        return true;
-      }
-    };
-    return returnObj;
-  }
+    query += ' SET %s %s';
 
-  var queryOptions = normalizer.normalize_query_option(options);
+    var where = '';
+    try {
+        var whereClause = parser.get_where_clause(schema, queryObject);
+        where = whereClause.query;
+        finalParams = finalParams.concat(whereClause.params);
+    } catch (e) {
+        parser.callback_or_throw(e, callback);
+        return {};
+    }
 
-  this._execute_table_query(query, finalParams, queryOptions, function (err, results) {
-    if (typeof callback === 'function') {
-      if (err) {
-        callback(buildError('model.update.dberror', err));
-        return;
-      }
-      if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
-        callback(buildError('model.update.after.error'));
-        return;
-      }
-      callback(null, results);
-    } else if (err) {
-      throw buildError('model.update.dberror', err);
-    } else if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
-      throw buildError('model.update.after.error');
+    query = util.format(query, this._properties.table_name, updateClauses.join(', '), where);
+
+    if (options.conditions) {
+        var ifClause = parser.get_if_clause(schema, options.conditions);
+        if (ifClause.query) {
+            query += util.format(' %s', ifClause.query);
+            finalParams = finalParams.concat(ifClause.params);
+        }
+    } else if (options.if_exists) {
+        query += ' IF EXISTS';
+    }
+
+    query += ';';
+
+    if (options.return_query) {
+        var returnObj = {
+            query,
+            params: finalParams,
+            after_hook: function after_hook() {
+                if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
+                    return buildError('model.update.after.error');
+                }
+                return true;
+            }
+        };
+        return returnObj;
     }
-  });
 
-  return {};
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    this._execute_table_query(query, finalParams, queryOptions, function(err, results) {
+        if (typeof callback === 'function') {
+            if (err) {
+                callback(buildError('model.update.dberror', err));
+                return;
+            }
+            if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
+                callback(buildError('model.update.after.error'));
+                return;
+            }
+            callback(null, results);
+        } else if (err) {
+            throw buildError('model.update.dberror', err);
+        } else if (typeof schema.after_update === 'function' && schema.after_update(queryObject, updateValues, options) === false) {
+            throw buildError('model.update.after.error');
+        }
+    });
+
+    return {};
 };
 
 BaseModel.delete = function f(queryObject, options, callback) {
-  if (arguments.length === 2 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
-
-  var schema = this._properties.schema;
+    // console.log('caching:delete:sl', countttt, 'tbl:', this._properties.table_name, 'qryObj:', JSON.stringify(queryObject));
+    // _queryObject = queryObject;
+    if (arguments.length === 2 && typeof options === 'function') {
+        callback = options;
+        options = {};
+    }
 
-  var defaults = {
-    prepare: true
-  };
+    var schema = this._properties.schema;
 
-  options = _.defaultsDeep(options, defaults);
+    var defaults = {
+        prepare: true
+    };
 
-  if (typeof schema.before_delete === 'function' && schema.before_delete(queryObject, options) === false) {
-    parser.callback_or_throw(buildError('model.delete.before.error'), callback);
-    return {};
-  }
-
-  var queryParams = [];
-
-  var query = 'DELETE FROM "%s" %s;';
-  var where = '';
-  try {
-    var whereClause = parser.get_where_clause(schema, queryObject);
-    where = whereClause.query;
-    queryParams = queryParams.concat(whereClause.params);
-  } catch (e) {
-    parser.callback_or_throw(e, callback);
-    return {};
-  }
+    options = _.defaultsDeep(options, defaults);
 
-  query = util.format(query, this._properties.table_name, where);
+    if (typeof schema.before_delete === 'function' && schema.before_delete(queryObject, options) === false) {
+        parser.callback_or_throw(buildError('model.delete.before.error'), callback);
+        return {};
+    }
 
-  if (options.return_query) {
-    var returnObj = {
-      query,
-      params: queryParams,
-      after_hook: function after_hook() {
-        if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
-          return buildError('model.delete.after.error');
-        }
-        return true;
-      }
-    };
-    return returnObj;
-  }
+    var queryParams = [];
 
-  var queryOptions = normalizer.normalize_query_option(options);
+    var query = 'DELETE FROM "%s" %s;';
+    var where = '';
+    try {
+        var whereClause = parser.get_where_clause(schema, queryObject);
+        where = whereClause.query;
+        queryParams = queryParams.concat(whereClause.params);
+    } catch (e) {
+        parser.callback_or_throw(e, callback);
+        return {};
+    }
 
-  this._execute_table_query(query, queryParams, queryOptions, function (err, results) {
-    if (typeof callback === 'function') {
-      if (err) {
-        callback(buildError('model.delete.dberror', err));
-        return;
-      }
-      if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
-        callback(buildError('model.delete.after.error'));
-        return;
-      }
-      callback(null, results);
-    } else if (err) {
-      throw buildError('model.delete.dberror', err);
-    } else if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
-      throw buildError('model.delete.after.error');
+    query = util.format(query, this._properties.table_name, where);
+
+    if (options.return_query) {
+        var returnObj = {
+            query,
+            params: queryParams,
+            after_hook: function after_hook() {
+                if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
+                    return buildError('model.delete.after.error');
+                }
+                return true;
+            }
+        };
+        return returnObj;
     }
-  });
 
-  return {};
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    this._execute_table_query(query, queryParams, queryOptions, function(err, results) {
+        if (typeof callback === 'function') {
+            if (err) {
+                callback(buildError('model.delete.dberror', err));
+                return;
+            }
+            if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
+                callback(buildError('model.delete.after.error'));
+                return;
+            }
+            callback(null, results);
+        } else if (err) {
+            throw buildError('model.delete.dberror', err);
+        } else if (typeof schema.after_delete === 'function' && schema.after_delete(queryObject, options) === false) {
+            throw buildError('model.delete.after.error');
+        }
+    });
+
+    return {};
 };
 
 BaseModel.truncate = function f(callback) {
-  var properties = this._properties;
-  var tableName = properties.table_name;
+    var properties = this._properties;
+    var tableName = properties.table_name;
 
-  var query = util.format('TRUNCATE TABLE "%s";', tableName);
-  this._execute_table_query(query, [], callback);
+    var query = util.format('TRUNCATE TABLE "%s";', tableName);
+    this._execute_table_query(query, [], callback);
 };
 
 BaseModel.prototype.get_data_types = function f() {
-  return cql.types;
+    return cql.types;
 };
 
 BaseModel.prototype.get_table_name = function f() {
-  return this.constructor.get_table_name();
+    return this.constructor.get_table_name();
 };
 
 BaseModel.prototype.get_keyspace_name = function f() {
-  return this.constructor.get_keyspace_name();
+    return this.constructor.get_keyspace_name();
 };
 
 BaseModel.prototype._get_default_value = function f(fieldname) {
-  var properties = this.constructor._properties;
-  var schema = properties.schema;
+    var properties = this.constructor._properties;
+    var schema = properties.schema;
 
-  if (_.isPlainObject(schema.fields[fieldname]) && schema.fields[fieldname].default !== undefined) {
-    if (typeof schema.fields[fieldname].default === 'function') {
-      return schema.fields[fieldname].default.call(this);
+    if (_.isPlainObject(schema.fields[fieldname]) && schema.fields[fieldname].default !== undefined) {
+        if (typeof schema.fields[fieldname].default === 'function') {
+            return schema.fields[fieldname].default.call(this);
+        }
+        return schema.fields[fieldname].default;
     }
-    return schema.fields[fieldname].default;
-  }
-  return undefined;
+    return undefined;
 };
 
 BaseModel.prototype.validate = function f(propertyName, value) {
-  value = value || this[propertyName];
-  this._validators = this._validators || {};
-  return schemer.get_validation_message(this._validators[propertyName] || [], value);
+    value = value || this[propertyName];
+    this._validators = this._validators || {};
+    return schemer.get_validation_message(this._validators[propertyName] || [], value);
 };
 
 BaseModel.prototype.save = function fn(options, callback) {
-  var _this7 = this;
 
-  if (arguments.length === 1 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
+    var _this7 = this;
+    // _instance = this;
 
-  var properties = this.constructor._properties;
-  var schema = properties.schema;
+    if (arguments.length === 1 && typeof options === 'function') {
+        callback = options;
+        options = {};
+    }
 
-  var defaults = {
-    prepare: true
-  };
+    var properties = this.constructor._properties;
+    var schema = properties.schema;
+    // console.log('caching:insert:sl:', countttt, properties.table_name);
+    var defaults = {
+        prepare: true
+    };
 
-  options = _.defaultsDeep(options, defaults);
+    options = _.defaultsDeep(options, defaults);
 
-  if (typeof schema.before_save === 'function' && schema.before_save(this, options) === false) {
-    parser.callback_or_throw(buildError('model.save.before.error'), callback);
-    return {};
-  }
+    if (typeof schema.before_save === 'function' && schema.before_save(this, options) === false) {
+        parser.callback_or_throw(buildError('model.save.before.error'), callback);
+        return {};
+    }
 
-  var _parser$get_save_valu = parser.get_save_value_expression(this, schema, callback),
-      identifiers = _parser$get_save_valu.identifiers,
-      values = _parser$get_save_valu.values,
-      queryParams = _parser$get_save_valu.queryParams,
-      errorHappened = _parser$get_save_valu.errorHappened;
+    var _parser$get_save_valu = parser.get_save_value_expression(this, schema, callback),
+        identifiers = _parser$get_save_valu.identifiers,
+        values = _parser$get_save_valu.values,
+        queryParams = _parser$get_save_valu.queryParams,
+        errorHappened = _parser$get_save_valu.errorHappened;
 
-  if (errorHappened) return {};
+    if (errorHappened) return {};
 
-  var query = util.format('INSERT INTO "%s" ( %s ) VALUES ( %s )', properties.table_name, identifiers.join(' , '), values.join(' , '));
+    var query = util.format('INSERT INTO "%s" ( %s ) VALUES ( %s )', properties.table_name, identifiers.join(' , '), values.join(' , '));
 
-  if (options.if_not_exist) query += ' IF NOT EXISTS';
+    if (options.if_not_exist) query += ' IF NOT EXISTS';
 
-  var finalParams = queryParams;
-  if (_.isNumber(options.ttl)) {
-    query += ' USING TTL ?';
-    finalParams = finalParams.concat([options.ttl]);
-  }
+    var finalParams = queryParams;
+    if (_.isNumber(options.ttl)) {
+        query += ' USING TTL ?';
+        finalParams = finalParams.concat([options.ttl]);
+    }
 
-  query += ';';
+    query += ';';
+
+    if (options.return_query) {
+        var returnObj = {
+            query,
+            params: finalParams,
+            after_hook: function after_hook() {
+                if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
+                    return buildError('model.save.after.error');
+                }
+                return true;
+            }
+        };
+        return returnObj;
+    }
 
-  if (options.return_query) {
-    var returnObj = {
-      query,
-      params: finalParams,
-      after_hook: function after_hook() {
-        if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
-          return buildError('model.save.after.error');
+    var queryOptions = normalizer.normalize_query_option(options);
+
+    this.constructor._execute_table_query(query, finalParams, queryOptions, function(err, result) {
+        if (typeof callback === 'function') {
+            if (err) {
+                callback(buildError('model.save.dberror', err));
+                return;
+            }
+            if (!options.if_not_exist || result.rows && result.rows[0] && result.rows[0]['[applied]']) {
+                _this7._modified = {};
+            }
+            if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
+                callback(buildError('model.save.after.error'));
+                return;
+            }
+            callback(null, result);
+        } else if (err) {
+            throw buildError('model.save.dberror', err);
+        } else if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
+            throw buildError('model.save.after.error');
         }
-        return true;
-      }
-    };
-    return returnObj;
-  }
-
-  var queryOptions = normalizer.normalize_query_option(options);
-
-  this.constructor._execute_table_query(query, finalParams, queryOptions, function (err, result) {
-    if (typeof callback === 'function') {
-      if (err) {
-        callback(buildError('model.save.dberror', err));
-        return;
-      }
-      if (!options.if_not_exist || result.rows && result.rows[0] && result.rows[0]['[applied]']) {
-        _this7._modified = {};
-      }
-      if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
-        callback(buildError('model.save.after.error'));
-        return;
-      }
-      callback(null, result);
-    } else if (err) {
-      throw buildError('model.save.dberror', err);
-    } else if (typeof schema.after_save === 'function' && schema.after_save(_this7, options) === false) {
-      throw buildError('model.save.after.error');
-    }
-  });
+    });
 
-  return {};
+    return {};
 };
 
 BaseModel.prototype.delete = function f(options, callback) {
-  if (arguments.length === 1 && typeof options === 'function') {
-    callback = options;
-    options = {};
-  }
-
-  var schema = this.constructor._properties.schema;
-  var deleteQuery = {};
-
-  for (var i = 0; i < schema.key.length; i++) {
-    var fieldKey = schema.key[i];
-    if (_.isArray(fieldKey)) {
-      for (var j = 0; j < fieldKey.length; j++) {
-        deleteQuery[fieldKey[j]] = this[fieldKey[j]];
-      }
-    } else {
-      deleteQuery[fieldKey] = this[fieldKey];
+    if (arguments.length === 1 && typeof options === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    var schema = this.constructor._properties.schema;
+    var deleteQuery = {};
+
+    for (var i = 0; i < schema.key.length; i++) {
+        var fieldKey = schema.key[i];
+        if (_.isArray(fieldKey)) {
+            for (var j = 0; j < fieldKey.length; j++) {
+                deleteQuery[fieldKey[j]] = this[fieldKey[j]];
+            }
+        } else {
+            deleteQuery[fieldKey] = this[fieldKey];
+        }
     }
-  }
 
-  return this.constructor.delete(deleteQuery, options, callback);
+    return this.constructor.delete(deleteQuery, options, callback);
 };
 
 BaseModel.prototype.toJSON = function toJSON() {
-  var _this8 = this;
+    var _this8 = this;
 
-  var object = {};
-  var schema = this.constructor._properties.schema;
+    var object = {};
+    var schema = this.constructor._properties.schema;
 
-  Object.keys(schema.fields).forEach(function (field) {
-    object[field] = _this8[field];
-  });
+    Object.keys(schema.fields).forEach(function(field) {
+        object[field] = _this8[field];
+    });
 
-  return object;
+    return object;
 };
 
 BaseModel.prototype.isModified = function isModified(propName) {
-  if (propName) {
-    return Object.prototype.hasOwnProperty.call(this._modified, propName);
-  }
-  return Object.keys(this._modified).length !== 0;
+    if (propName) {
+        return Object.prototype.hasOwnProperty.call(this._modified, propName);
+    }
+    return Object.keys(this._modified).length !== 0;
 };
 
 module.exports = BaseModel;
